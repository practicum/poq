
In order to gauge whether it is worthwhile to build {{such a tool}} (put wording that ties in to preceding sections), it will be helpful to know how it might be applied in practice.  Therefore, in this section, we will imagine that a SQL verification tool exists, and we will examine the ways in which it could be applied.

The imagined tool will parse SQL code, parse DDL code, and also parse table-size and tuple-membership assertions.  The tool will then determine whether the assertions are valid for the given database schema.  If the given SQL and DDL admit any database state that would also cause a table-size or tuple-membership assertion to fail, then the tool will output one or more sample states in demonstration of these assertion violations.

Since the tool provides formal proof or refutation of assertion validity, it would seem that an obvious setting for the tool would be in critical systems development.  Critical systems have historically been the biggest adopters of formal methods in software.  Projects typically labeled as critical systems are flight control software and systems that regulate nuclear power plants.  Such projects, however, typically do *not* include SQL code.

However, there are other types of projects that might not be labeled critical but nonetheless are considered high-stakes projects, and that may even have a legal requirement or contractual obligation to achieve some formal certification of system correctness.  This tier of high-risk software includes financial applications and medical record-keeping systems.  These types of systems do tend to use a moderate to large amount of SQL code.

Unfortunately, our imagined SQL assertion-checker tool is probably still not sufficient to *certify* such financial and medical applications.  The reason is that even if the SQL code is verified, bugs in the underlying RDB system could still cause query results that violate the tested assertions.  The only way to rely on our SQL verification tool for complete system certification would be to guarantee that the verified SQL code will in turn only be executed on a verified RDB.  Inroads are being made into verified RDB systems [], but no such commercial-grade RDB yet exists.

Therefore, our imagined formal tool does not seem immediately applicable to high-stakes settings where formal methods currently have traction.  Understandably, then, our tool should be met with skepticism were this its only intended use.  Thankfully, as later chapters of this thesis will show, a SQL verfication tool can quite aptly perform duties that look more like today's testing and debugging techniques than like formal certification.

To understand how such a tool can be applied to a debugging objective, take the example in Figure ___. (do setup of what that code is).

A manager has recieved a summary report listing "<part-a, TOOHEAVY>, <part-a, TOOHEAVY>."  The manager accordingly reports that there is a bug in report generation that causes the same product complaint to appear twice in the same report.  A software developer is assigned to diagnose this bug.  The software developer runs the report query against several test database instances but is unable to generate a report containing a duplicate product complaint.  At this point in the diagnosis it is helpful to apply the SQL assertion-checker tool.  In order to "debug" using the tool, the developer will annotate the query with an assertion "NOT [ member() and member() ]" and the tool will return a counterexample like "       ."  In this way, the tool finds a scenario that reproduces the bug whereas the developer had failed to do so by trial and error.  At this point, the developer might notice that in the counterexample, the product id corresponding to the duplicate complaint is an id that appears in *both* base tables.  To determine whether that is the *only* way the duplication can occur, the original debugging assertion can be augmented like so: _______________.  With the augmented assertion, no counterexample is produced.  Therefore, the developer can conclude that the bug's root cause is that the query fails to handle the case when a given product id (-complaint pair) is present in both TABLE-BLA and TABLE-ZDR.  Such a bug may have been introduced by a developer that assumed the set of customer complaint codes was distinct from the set of internal employee complaint codes.  A debugging investigation is successfully completed with the aid of the SQL assertion-checker tool.

The foregoing example is unrealistic in one small way.  The only contrivance is the implicit idea that Query XYZ (name matching figure) is too daunting for a developer to diagnose without tool support.  In reality, any reasonably skilled SQL user should be able to diagnose this particular bug without difficulty.  However, the example is designed to show the feasibility and practicality of the described *workflow*, regardless of the size and complexity level of any individual query.  The example query is small to simplify discussion.  It should be clear that this tool-supported workflow is equally applicable for diagnosing queries involving more than two base tables and more than OOO (count them from figure) SQL operations.  Each developer will differ in deciding which queries can be tackled manually and which queries call for tool-supported debugging.  The same state of affairs exists with imperative debugger tools; some developers can spot certain bugs rapidly by manual code inspection, where other developers do not grasp the bug's full nature until stepping through the code with a debug tool.  The important thing is to have tools available when they are needed.  Step-through debuggers are readily available for imperative code.  Tools for debugging relational SQL are currently non-existent.

The term *step-through debugging* in imperative languages refers to executing consecutive statements one at a time, stopping after each statement to observe the system state.  The all-at-once nature of a SQL statement render the usual step-through approach inapplicable.  To debug a SQL statement, one might apply a novel definition of *step-through debugging* that hinges upon stepping through *states* rather than statements.  With SQL statements, one might prefer to systematically step through different isomorphic database states, pausing with each new state to observe how the SQL statement performs for the given state.

The preceding "product..." example shows that our imagined tool can play the role of a debugger.  The final goal of this section is to show how the tool can function in place of a more traditional testing system.

On many software projects, the development team adheres to a policy of adding a new test to a test suite each time a new bug is diagnosed.  In the "" scenario just described, the bug would be fixed, and then a related test script would be created.  The test script would loads data into a database instance, run the current version of the SQL query, then check whether or not any product complaint appears more than once in the result.  The original SQL query would have failed such a test.  Once the SQL code is repaired, scheduling the test script to be executed at regular intervals will protect the development team from ever accidentally reintroducing the same bug later on.  These tests are commonly called regression tests.

An assertion-checker tool can participate in regression testing just as it did for debugging.  All that is required is to enable the assertion-checker to automatically reverify "_______________" against the current SQL and DDL at regular intervals.  This can replace the running of test scripts at regular intervals.  This is desirable because it circumvents the need to repeatedly setup and destroy test database instances.  Furthermore, it is easier to write a concise assertion than it is to write a multi-line imperative script that includes database creation and table population and so forth.

Of course, the only reason regression tests have a special name is to indicate the cause that motivated their inclusion in the test suite.  Regression tests are created reactively, in response to newly-discovered bugs.  However, there is nothing unique in the structure or usage of regression tests that would differentiate them from proactively created tests.  Therefore, if our imagined SQL verification tool can replace regression tests, then it can replace other tests as well.  Accordingly, the last example of this section deals with proactively written tests.

One setting in which tests are inarguably proactive is in Test-Driven Development (TDD).  When applying TDD, a developer will not write application code until he/she has deeply considered how the output of the planned new code will look in a variety of circumstances.  Based on these considerations, tests are created that will detect whether or not the final application code matches the expected outcomes.  Also, a small piece of naive "stub" code is created that can be exercised by the test.  The stub code is initially designed to fail.  Once the test and stub are runnable, then an actual implementation is crafted to replace the stub code.  By applying TDD, the developer ensures that every part of the application has one or more tests enforcing the continued proper behavior the code during all future evolutions of the codebase.  Proactive test coverage such as this can be particularly important in applications that must continue to remain reverse-compatible with historically supported input formats or historically supported guarantees of legacy APIs.

Figure ____ will help illustrate how a SQL verification tool could be used in a TDD-like development style.
