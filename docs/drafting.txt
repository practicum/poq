

applying the "hot, fast-growth" concepts from formal verification to the "underserved" area of SQL code.


composing SQL queries is only beginning to receive attention that treats it as a software engineering exercise.

(on the other hand, dbms design and management and profiling has received a lot of attention)

tool support is crucial for accepting a programming language as being 'ready for prime time'.

(again, we see tools for management but not for the coding.  perhaps this is why many applications exist where all the data is indeed stored and distributed and access-controlled via a DBMS, but rather than compose SQL code the main code is all done in Java or PHP or {other}, where chunks of data are pulled from the DBMS into arrays [using only the most trivially basic SQL], and then Java or PHP is manipulating these arrays.)

perhaps an explanation of lack of tools: SQL defies "cross-over" effects -- stuff developed for other languages just does not apply!

also perhaps an explanation: we mistake "declarative" as meaning "make only obvious and clear statements." (if that were indeed true, then no testing or debugging or quality assurance would be needed).  however, all programming languages are *unambiguous*, so we could similarly try to conclude that since what you type in any programming language means exactly what it is designed to mean in that language, then nothing should go wrong.  obviously this has not held true in any real life realm. also, even if programmers indeed managed to master the full logical entailments/consequences of evern line of code they write, we would still at LEAST need double-checking mechanisms just to weed out 'typos', like:

if ( x = 0 )

instead of

if ( x == 0 )

assertions are a simple cross-check/sanity-check/double-check, consistency check.

compare run-time assertions with statically provable assertions.  runtime assertions still require that we EXERCISE the code to be checked, and that we exercise it with as many different states as possible. static checking does not rely on that type of exercising.  also: how would one use run-time assertions on SQL? (no..  you actually could do it in a fairly straightforward way, but it isn't built in.)


Quality assurance, debugging, and maintenance tools are all needed.


Formal verification has been experiencing a steady growth and a stream of successes.  Based on FOL. Relational ___ based on FOL. Therefore, applying formal verification to assertions about a piece of relation SQL code is a natural fit.

Another fact (which follows from the previous one, or is a corollary to it) is that a SQL query is side-effect free -- it is pure functional.  This is a common condition that is sought in code in any language whenever attempts at formal verification are to be made.

We can apply something like the Hoare deduction techniques but with while-loops and loop-invariants notably absent.  That is significant since inferring loop-invariants is still not a well-solved problem.

We don't have procedure calls in rSQL.

(do we have any aliasing issues at all?)

It has been shown to work in (microsoft paper, alloy texas paper).



preconditions in the POQ case are the constraints to the input tables?

Hoare logic attempts to lead to a proof of correctness.  It does not serve to provide any counter-assignments in failure cases?


in my tool, are joins only allowed when one side of the join is a primary-key col? (non-null). otherwise... i think i will end up with NULL joining to NULL, which is bad.  how could i avoid that?

microsoft paper and alloy paper show that formal verification of rSQL is successful. the new contribution here (mine) is to allow the query author to verify that the query conforms to a SPECIFICATION. (prior work was about generating and populating test databases and/or verifying the correctness of the query execution engine)

double-check: in my listings of 'weaknesses/troublespots' of choosing prolog, did i mention that everything has to be expressed in Horn clause form?  (which is obviously fine. it is also similar to how the microsoft Z3 paper did it anyway)

another thing for the 'weaknesses/troublespots': prolog doesnt have syntactic sugar for the MANY SORTED case. many-sorted case comes from adding extra predicates per ___ (per variable? per object?) like is_int or is_string or what have you.

Prolog has been a successful base (or influence?) on: SETHEO, PTTP, ...

CONSIDERATIONS FOR 'TRANSLATING' THE QUERY INTO PROLOG:

1. Prolog casing requirements. Capitalized things are variables! so lower case for all constants. also.. just atoms to represent strings.

2. we will use 'unifies' in prolog to equate to EQUALS in sql. this will work because all domains for all our table-column content are composed entirely of ground atoms in prolog.  Likewise, we will use 'does not unify' for 'not equals'.

OTHER CONSIDERATIONS OF THE PROLOG TOOL IMPLEMENTATION:

it is sometimes hard to generate a list of a desired length. for example... it might take a really long time to ask to for a primary-keyed list of size five, but not of size 2 or 3.  but if we 'seed' the length-5 list by using (reusing) what was generated for the size-2 or size-3 lists, we can meet our requirements (and in a more reasonable time).


RAMIFICATIONS OF NEGATION AS FAILURE:

if you have:

    conseq(X) :- aa(X), bb(X).
    nonconseq(X) :- \+ conseq(X).

then you cannot reasonably expect to query:

    ?- nonconseq(A).

it will just fail.

What this means (i think) is that anywhere I have \+something(X) I require X to be instantiated by then, right?

RAMIFICATIONS OF OCCURS CHECK BEING MISSING/PRESENT:

?- A=thing(A).
false.

?- thing(c(X,bla(X)))=thing(c(bla(X),Y)).
false.

?- current_prolog_flag(occurs_check,X).
X = true.

?- set_prolog_flag(occurs_check,false).
true.

?- current_prolog_flag(occurs_check,X).
X = false.

?- thing(c(X,bla(X)))=thing(c(bla(X),Y)).
X = bla(**),
Y = bla(bla(**)).

RAMIFICATIONS OF THE CUT:

so far my only use is with the nonnull predicate (i should continue to track any new uses)


CHRONOLOGICAL VIEW OF THE DEVELOPMENT OF THIS THESIS:

Began by looking at real-life DBMS and databases.

Began by looking at real-life Q.A. approach in those settings.

Then considering:

    if that were Java, we could:
        [runtime] assert( ____ );

    of if we were being really formal about it, then using Krakatoa/Why:
        [static assert]

So for SQL assertions, let's go for the more formal!

Why? Answer: because FOL makes it immediately possible.  (also, SQL in a high-value/high-risk financial settings makes formal verification very tantalizing).  Also: because there has already been preliminary success in this idea.

Next, we must choose a theorem prover.

SMT solver? No... we don't actually need those theories (LIA, UF, etc), and we do not want the back-and-forth coordination between the theory and a SAT-solver, theory and a SAT-solver, over and over.

(other issues with SMT solvers: quantifiers, 'quirks')

So just use good old fashioned Horn clauses and Resolution.  Create FOL predicates and implications, and then deduce conclusions based on that.

Next, we must devise encodings for taking SQL code and creating an appropriate FOL, horn-clause representation.
