

Building the POQ tool was not attempted without first surveying current literature for similar efforts.  Several interesting projects exist that each share a small overlap with the POQ project.  These related projects can be divided roughly into two groups.  One group of projects aims to prevent the embedded SQL code of an application from causing application errors.  Another group of projects focuses on ensuring the correctness of the RDB system itself, or the correctness of the state of the data stored therein.  The intent of POQ is identical to the former group's intent.  However, POQ's implementation has more in common with the latter group.  The latter group contains projects using formal methods (formal logic, constraint solving, theorem-proving), whereas the former group uses predictive static analysis tools that only give estimated results and suggested error causes.

Beginning with the formal-methods group, we first mention the Ynot-RDB project from Harvard [].  This is the most mathematically ambitious project of the group.  Ynot-RDB is a fully-verified RDB system implementation.  The Harvard team notes that a formally verified RDB system is a logical next step in verified system software now that verified compilers are a reality.  The team built Ynot-RDB using the Coq theorem-proving system, which then enabled the extraction of verified and executable OCaml source code.  The RDB supports SQL parsing, basic query optimization, SQL execution, a B+ tree implementation, and the serialization to disk of database tables.  All in all this is a very significant and successful application of formal verification.  Nonetheless, the team remarks that many substantial features of commercial RDB systems are not yet possible in Ynot-RDB.  These features include concurrency, a storage layer that tolerates disk I/O failures, and transaction support.  The availability of a fully verified RDB would be essential for anyone wishing to use POQ as part of a complete verification strategy of a critical application.  The fact that POQ verified a particular application-specific SQL statement would not provide complete confidence in overall application correctness unless the verified SQL code was then executed in a verified RDB.

In the area of greater table constraint support, a Microsoft team from Cambridge applied formal methods to data integrity preservation [].  The Cambridge paper applies formal verification to eliminate bugs in UPDATE/INSERT/DELETE statements run against a database.  In this case, a bug is taken as a statement that would change the data in such as way as to leave the data corrupt or anomalous with regard to some constraint that the data was supposed to obey.  Some of the constraints mentioned in the paper are already supported in modern RDB environments.  These include nullability constraints on columns and primary key integrity enforcement.  However, the novelty of the Cambridge team's work is two-fold.  First, they argue that the overhead of run-time constraint checking can be eliminated if the system is restricted to only run statements that were pre-verified.  In other words, during compile-time of an UPDATE/INSERT/DELETE command, the compiler can also perform verification that the statement is guaranteed to never leave data in a constraint-violating state.  The secondary benefit is that not only can the runtime overhead of currently-supported constraint-checking be eliminated, but additionally the barriers to expanded support for more generalized database constraint assertions is eliminated.  Historically the rationale given for not supporting more assertion-types in RDB systems is that the runtime cost of enforcement is too high.  The approach described by the Cambridge team removes those concerns.

The remaining formal methods project are the two that had the strongest influence on the POQ project.  These two projects are ADUSA [] from the University of Texas and Qex [] from Microsoft Research in Redmond, WA.  Both of these projects designed techniques for transforming SQL statements and SQL DDL code into sets of formal axioms and constraints based on relational calculus.  Both ADUSA and Qex then find satisfying table assignment values that obey all the generated constraints plus one additional constraint requiring that output from the original SQL query be a non-empty set.  The subset of relational SQL features supported by Qex is much more sophisticated than that supported by ADUSA.  However, the ADUSA team describe a much more complete end-to-end tool that not only produces satisfying table assignments but also connects to the RDB to create the tables and automatically test that the RDB output matches the output calculated by the constraint-solver.  Furthermore, even with the limited SQL features implemented in ADUSA, the ADUSA team discovered a bug in the production release of Oracle 11g Enterprise Edition.

The techniques employed in ADUSA and Qex are virtually identical to the technique employed in POQ.  However, the focus of POQ is unique.  POQ is thoroughly dedicated to verifying that a SQL *user* does not violate his/her own assumptions about the SQL code he/she is writing.  POQ is intended to be used when the RDB is already taken as a *trusted* RDB engine.  In other words, the RDB is simply presumed correct, and POQ is used to produce greater confidence in the custom SQL code that RDB users will write.  ADUSA and Qex, on the other hand, are solely focused on verifying that the RDB itself is behaving correctly.  With ADUSA and Qex, the purpose of generating satisfying table assignments tailored to a given SQL query is to verify that the RDB query engine executes the SQL code and produces the formally calculated correct result.  ADUSA and Qex perform sanity-checking that will help an RDB implementer, not an RDB user.

Due to the differing focus of POQ, POQ must contend with a broader range of auxiliary constraints.  POQ supports postcondition constraints that establish relationships between tuples belonging to the input tables and the derived output table.  This is necessary in order to meet the goal of helping SQL users establish that a query means what the user intented it to mean.  ADUSA and Qex, meanwhile, only impose a single auxiliary constraint after the SQL query itself is transformed into basic axioms.  The single auxiliary constraint in ADUSA and Qex is that the derived output table be non-empty.  The simplicity of the single non-empty result constraint is perfectly suited to the use cases for those two tools.

The difference in supported constraint types between POQ and its predecessors is one of two key differences that stem from their different use cases.  The other key difference is that when Qex and ADUSA find a *satisfying* assignment, then success has been achieved.  In contrast, a POQ user will not have achieved success until POQ determines that a given scenario is *unsatisfiable*.  ADUSA and Qex only need satisfying assignments, because they wish to obtain concrete values that can be loaded into an actual RDB for testing.  POQ, on the other hand, produces satisfying assignments only when the user's assumptions are flawed.  Thus, the typical POQ use case involves a user trying modified SQL queries again and again until POQ determines there is *no* assignment that would violate the postconditions.  Unfortunately, as the POQ performace data show (Figure JJJ), it takes longer to exhaustively determine there are no assingments than it does to "short-circuit" and halt computation after the first assignment is found.

Particularly in terms of performance, POQ has a ways to go before matching the success of ADUSA and Qex.  POQ has benefited from the pioneering techniques of ADUSA and Qex, and perhaps POQ can further benefit from them still.  The success of ADUSA and Qex could indicate that future versions of POQ might do well do replace the Prolog engine with one of the two engines used in the other projects.  Those alternative logic engines are the Alloy Analyzer constraint solver [] (used in ADUSA) and Microsoft's Z3 SMT solver [] (used in Qex).

As shown by the preceding discussion, POQ is preceded by a number of interesting projects that apply formal techniques to varying problems in a SQL/RDB setting.  However, no known formal methods projects have targeted the problem that POQ targets.  The POQ project is driven by the goal of aiding application developers create and maintain SQL code that is as bug-free as possible.  While no prior formal methods projects seems to target this problem, there are projects rooted in more traditional testing and maintenance disciplines that do target quality assurance in SQL application code.

The SUITE tool [] from University College London is designed to analyze any C# application that contains embedded SQL statements, and to locate all parts of the application that might become broken due to a change in the underlying database schema.  The supported types of schema changes in SUITE include dropped columns, the addition of new columns, changes to the data type of a column, and changes to column constraints.  When schema changes like these are required, the SUITE tool is designed to automatically find the parts of the application that must also change to preserve correctness of the application.  First, program slicing is used to isolate those parts of the C# application that interact with the RDB.  This isolated code is then analyzed to generate the predicted string values of SQL statement variables that the application passes to the RDB at runtime.  The SUITE tool is preloaded with a set of impact descriptions, such as "query references an invalid column."  The predicted SQL strings are compared to the impact descriptions to determine with SQL queries generated in the application are impacted by the schema changes.  The SUITE team reports the success of a case-study which analyzed a large C# commercial web-publishing application.  In the study, the SUITE tool correctly located four sites where application code required fixing due to eight schema changes to the database.  The SUITE tool ocassionally predicted application changes that ended up being unnecessary.  However, the tool never missed any location where actual application errors would have emerged had the locations gone unnoticed.

Another effort aimed at quality assurance of the SQL embedded in a larger application comes from the University of Manchester [].  The goal of this work was to identify existing general-purpose testing tools and techniques that can be successfully adapted to bugs in embedded SQL code rather than in the main application code.  The project focused on semantic errors in SQL code causing erroneous outcomes with incorrect tuples or missing tuples.  The core technique requires that there is a test suite that wraps the outer application.  Each test in the suite has a known required outcome.  Since the tests are written against the outer application interface, the tests themselves need not involve SQL at all.  An automated tool is designed that uses existing defect localization techniques to determine whether the blame for a failed test belongs to an embedded SQL statement or to some non-SQL part of the application.  In a Java application with 15 injected SQL faults, the approach correctly identfied the faulty queries as "highly suspicious" with regard to the failed tests.  The paper also discussed future possibilities for automatically calculating corrective actions to repair faulty queries, but those ideas are not yet implemented.

The teams responsible for the preceding projects have all argued in favor of one or more ideas that are important to this thesis.  The SUITE team postulates that better analysis of application-embedded SQL could foster the confidence that would allow more frequent and worry-free refactorings of the database schema [].  The University of Manchester team makes the point that because step-through debugging does not work for application-embedded SQL statements, novel tools must be developed to help diagnose SQL errors in an application [].  The Harvard and Cambridge teams offer ideas on how to support a wider range of generalized constraints in a database by relying on formal methods [], [].  And while the Harvard team focused on building a new, fully-verified RDB system [], the Qex and ADUSA projects show that more rigurous testing of existing RDB systems is achievable via formally-generated test cases [], [].

All of these projects are complementary.  In the future, it would be wonderful to see tool suites for SQL users that incorporate ideas from all these projects, as well as from POQ.
