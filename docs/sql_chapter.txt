
The Focus of Our Assertions: SQL


This chapter has three main objectives.  First, the SQL language will be placed in context according to its common usage and its relative power compared to other programming languages.  Second, various restrictions are given to delineate the precise subset of SQL that is explored throughout the remainder of this thesis.  Third, a modest taxonomy of SQL bugs will be discussed in order to highlight the need for better tool support surrounding this language.

1. Context  --------- SUBSECTION -----------

SQL is now so ubiquitous in computing and in business that in some ways SQL requires no introduction. Virtually every institution that offers instruction in computer programming includes courses that cover SQL.  Therefore, any student or teacher in this field has undoubtedly heard of SQL.  ..... , many non-technical office workers today will also have some notion of the term SQL.

(confoundingly? some transition) ... precisely owing to this ubiquity, some preliminary definitions are required. SQL is so [ubiquitous.. diffuse.. widely-dispersed?]  that it now means a great many different things to a great many different people, and it is therefore necessary to delineate exactly what the term SQL should be taken to mean in this thesis. (alternative: 'carries a great many different connotations to a great many...')

(firstly..) this thesis considers only those uses of SQL which are dependent on an underlying relational database (RDB).  It may be possible to find uses for the SQL language in absense of any RDB, but in practice this is rarely done.  For this reason, whenever a phrase such as "the use of SQL" is present in this thesis, the implied meaning is "the use of SQL in conjunction with some RDB".

Next, I assume the reader has a basic familiarity with the SQL language.  Specifically, I assume that the reader knows that a typical 'hello world' type of statement would look like:

SELECT last_name
FROM   Employee
WHERE  ;

and such a statement would retrieve from the database a result containing the last names of all employees in the system ... .

... some transition here ...

Is SQL a programming language?  To answer this question, we take a restricted definition of programming language that states: X is a programming language iff X is a Turing complete language.  We then answer the equivalent question: is SQL a Turing complete language?

The answer turns out to be "yes," but not due to the rationale that has traditionally been put forth.  Until a few years ago, SQL was only considered to be Turing complete in the presence of vendor-specific (non-standard) language extensions.  Many vendors provided add-on constructs for variable declarations, branching, and iteration that would allow (non-standard) SQL code to achieve Turing completeness.

Without such extensions, however, SQL fell short of Turing completeness.  Basic, standard SQL instructions could only produce a limited type of tabular output; no combination of these instructions could compute the type of algorithms entailed by Turing completeness.

(so) Turing completeness was, for a long time, absent from SQL.

(however) To the surprise and delight of many SQL users and researchers, David Fetter gave a talk at OSCON 2009 where he presented Andrew Gierth's work proving that core standard SQL is indeed Turing complete on its own, using only declarative relational statements and eschewing procedurals constructs.  The crucial pieces of SQL used for this achievement are recursive expressions and window functions.  Recursive expressions have been present in standard SQL since the 1999 standard.  Such constructions allow a relational expression to be defined in terms of itself.  Window functions entered the language with the 2003 standard, and they make interrow calculations possible in a single statement.  In the OSCON talk ... mandelbrot and traveling salesman...

It is now known, then, that standard foundational SQL is Turing complete.  However, practitioners have been highly productive with SQL for several decades without using it in a Turing complete manner.  Furthermore, the majority of SQL applications at the present time still do not use standard SQL as a Turing complete language.

(some nice 'sum-up' here: theoretic result that yes, but real-life usage patterns that say 'no'. (or no thank you). )

Everyday practitioners are not treating SQL as a Turing complete language.  Therefore, by the strict definition of programming language given earlier, SQL is not programming language, at least in the hands of everyday practitioners.

If, in practice, SQL is not a programming language, then what is it?  Essentially, SQL --and the accompanying RDB environment-- serve a similar role to that of spreadsheet, but boosted with several orders of magnitude more storage capacity and performance.  The typical SQL/RDB system is a place to insert and store [huge] amounts of data. (then, crucially, additionally) the system makes that data continuously available for a wide range of calculations, inferences, and transformations.  Like spreadsheets, SQL/RDB systems are pervasive in settings related to finance, demographics, customer relationship management (CRM), and so on.  Unlike spreadsheets, however, SQL/RDB installations can consist of (massive) distributed systems with enormous storage capacity, continuous availability, fine-grained user access controls, and considerably improved performance.

The SQL language, then, is a useful notation for carrying out calculations.  It is a language for writing formulas that calculate some desired result over the data in the RDB.

Perhaps in part due to the spreadsheet similarities, most SQL users are inclined to envision the underlying data in the RDB as a table, as in Figure XXX.

(figures use a VeterinaryVisit table, with 3 columns: date-of-visit, pet-owner, pet. domains will be something like {Alice, Bob, Carol}, {Nov 1, Nov 2, Nov 3, Nov 4}, {dog, cat, bird, rabbit})

However, this is not the only possible representation.  Indeed, it may not be the most illuminating or useful representation.  Using tables can unduly emphasize a two-dimensional viewpoint.  In contrast, Figure YYY shows a three-dimensional representation of the same information.  In general, each row in a given RDB table represents a single point in an N-dimensional space, where N is the number of columns in the table.

This multi-dimensional viewpoint can be helpful in grasping the meaning of SQL-related terminology such as 'projection' and 'Cartesian product'.  For example, it may not be immediately obvious why the code in figure ZZ can be given the formal description of 'the projection of VeterinaryVisit on attributes ( , ).'  However, by examining a three-dimensional visualization (Figure NNN), we can clearly see that the data points are being projected from three-dimensional space onto a two-dimensional plane with axes __ and __.

Another alternative to tabular representations are predicate-based (predicate centric?) representations.  In this view, the (table schema? table definition?) of the VeterinaryVisit table specifies a predicate:

A visit happened on ___ wherein ____ brought his ___ to the clinic.

Let us name this predicate P1. Under this framework of analysing the RDB, by looking at the full contents of the VeterinaryVisit table, we conclude:

    P1( , , ) = true.
    P1( , , ) = true.
    P1( , , ) = true.

That is to say: "it is true that a visit happ .." and so forth.

Furthermore, we conclude the falsity of statements like "a visit happened on __ wherein __ brought his __ to the clinic."  In summary, a (table schema?) is an N-ary predicate, where N is the number of columns in the table.  Each row in the table provides a set of parameters that make the predicate evaluate to true.  (also, importantly), if a set of parameters does not appear as a row in the table, then we assume that the predicate evaluates to false for those values.  This presumption that the absense of a row signifies the falsity of the corresponding statment is called the Closed World Assumption.

what these two representations means...

the point of comparing these different visualizations extends beyond any debate over their

rel algebra, rel calc

We have now covered enough ground in this section to give a fairly satisfying definition of what SQL actually is.  It is a non Turing complete language that is used for expressing formulas that belong to the branch of mathematics known as relational algebra (and/or to the branch known as relational calculus).  Once the variables in the SQL formula are assigned values according to the current data residing in the RDB, then the result of the formula can be computed.  Assuming that the SQL practitioner writes an accurate formula, then the computed result is the answer to whatever question the practitioner had in mind regarding the data.

... anything else here? ...

This concludes the basic overview of what SQL is and how it relates to today's computing ecosystem.  In the next section, further subcomponents of the SQL language are considered in detail.  Certain features will be selected as having principal importance to this thesis, and other features will be set aside.

2. Zooming in. Defining the core.  --------- SUBSECTION -----------

Every SQL/RDB system on the market today is based on a pioneering insight due to E.F. Codd.  Codd is credited with the revolutionary insight that the mathematical concept of relations can be used to elevate stored data out of clunky representations tied to physical machine characteristics and decouple the logical structure of the data from its physical (on-disk) structure.

Prior to Codd's (work/ideas/paper), relational algebra could not be used to explain or theorize about (prior, older, historic?) databases in any way.  Nowadays, relational algebra is a suitable formalism for describing nearly all of the most common foundational operations used in SQL queries.

However, some commands and keywords in the SQL language have no mathematical analog in relational algebra.  Also, several SQL operators that are firmly based on relational operators nonetheless make departures from well-defined relational semantics in the presence of specific special-case RDB content (such as tables with no defined key).

Therefore, for this thesis to continue taking the view that SQL expresses relational formulas, it is necessary to establish a clear demarcation of which parts of the SQL language can be included in further analysis and which must be excluded.

As a first cut, we narrow the focus strictly to features included in 'Core SQL' of the SQL:1999 standard. (say something about 'conformance'). (say something about 'SQL/Foundation').

(justify why 1999 and not 2003 and 2008). nothing too notable has changed in the *relational* features in 2003 and 2008. also, there is some controversy about the decreased value and power of sql standardization in the years beyond 1999, due to the removal (absense? loss?) of a designated compliance-testing body.

By focusing on 'Core SQL' and excluding other optional parts of the 1999 standard, the most (notable? popular?) feature that we exclude are stored procedures, and the imperative scripting keywords.  (the 'if' statement, looping, and variables). (do i want to say anything further to justify the exclusion?)


non-relational programming: CURSOR,

parts that have more to do with system maintenance or coordination of processes: privilege, transactions.

things that are relational, but have poor commercial support and (not surprisingly) infrequent use: VIEWS, user-defined types.

things that should someday be in POQ, but not in a first version: more specialized (better word?) predicates such as BETWEEN and LIKE, datetime types,


interestingly, NATURAL JOIN is not in core SQL 1999. also: INTERSECT.



SQL is often described as declarative.  relational calculus is declarative more so than SQL.  Where SQL syntax is more suggestive of the relational calculus then the 'declarative' claim is likely to be true (example?).  However, relational algebra does describe concrete operations, and there is a defined order of operations when computing the value of a relational algebra expression.  In this sense, if a SQL expression is taken as a relational algebra expression, then we do expect an order of operations, and in this sense SQL is 'less declarative' (is this phrasing sound? perhaps not) than commonly believed.

the ever-present:

SELECT ... FROM ... WHERE

maps to the relational expression:

(project (restrict[] (product ) ) )

already we can see that the ordering is a bit mis-matched (better word.).

to make the point about order of operations more dramatically:

7 SELECT
1 FROM
3 JOIN
2 ON
4 WHERE
5 GROUP BY
6 HAVING
8 ORDER BY

(i might have some qualms about 2 and 3. perhaps collapse that to avoid the issue...)

we should also mention that the entire relational algebra can be 'covered' (i dunno... what's the real word?) by choosing one of several possible minimal sets of operators.  one is: restrict, project, product, union, difference.


SQL's departures from 'relationality':

duplicate rows (in base tables and derived tables)
nulls
sequencing/ordering (relations have none, even in relation 'headings', potentially)
fails to obey 'every attribute name in a tuple heading is unique' (goes with the above about relation headings)
equality comparison of strings (PAD SPACE, and 'equal but distinguishable' or whatever the jargon is)
lack of a proper BOOLEAN type
automatic type coercion
no proper aggregation, only summarization
many anomalies in handling of empty set

(departures even in the subset we are restricting ourselves to)


3.  Taxonomy of SQL Bugs  --------- SUBSECTION -----------








keywords.

vendors.

standards.


SQL 1999 core. relational closure, nesting.  not (in this paper) interested in a turing complete SQL.
SQL 1999 was a big leap over 92.

SQL/Foundation section has hardly changed in 2003 and 2008.

/*
No books cover SQL:2008 yet. Regarding the previous standard, SQL:2003, the only book covering the subject is in German which I was never any good at. Therefore, I also use the following book as reference:
Jim Melton and Alan Simon: SQL:1999—Understanding Relational Language Components (ISBN 1-55860-456-1).

http://troels.arvin.dk/db/rdbms/


*/

r-sql^pe












http://wiki.postgresql.org/wiki/Mandelbrot_set

http://stackoverflow.com/questions/900055/is-sql-or-even-tsql-turing-complete

http://assets.en.oreilly.com/1/event/27/High%20Performance%20SQL%20with%20PostgreSQL%20Presentation.pdf


SAVE FOR LATER: http://www.wiscorp.com/book_v1dsm.pdf

also for later: http://developer.mimer.com/validator/comparison/upd_comparison_chart.tml

SAVE: http://docs.oracle.com/cd/B28359_01/server.111/b28314/tdpdw_sql.htm#CIHICDAE

/*
SQL 1999 Features
•
•
•
•
©2001
Regular Expressions
Recursive queries
Procedural statements
Triggers
Irwin Levinstein
Later Standards
• SQL 2003
– Some XML features
f
– Window functions
– Auto generation
• SQL 2006
– Lots of XML
• SQL 2008
– Instead Of triggers


http://www.jcc.com/sql.htm
*/

-- iterrow calculations:  http://docs.oracle.com/cd/B28359_01/server.111/b28314/tdpdw_sql.htm#CIHICDAE


--keywords count stuff:

http://stackoverflow.com/questions/4980766/reserved-keywords-count-by-programming-language

http://repeatgeek.com/technical/keyword-counts-of-popular-programming-languages/

http://www.sqlite.org/lang_keywords.html

http://publib.boulder.ibm.com/infocenter/idshelp/v115/index.jsp?topic=%2Fcom.ibm.sqls.doc%2Fids_sqs_1951.htm

http://msdn.microsoft.com/en-us/library/aa238507%28v=sql.80%29.aspx

http://www.wiscorp.com/is_sql_a_real_standard.pdf
