
The central idea in this thesis is that SQL practitioners can benefit greatly from an assertion-checking system that can verify relevant user-assumptions surrounding the user-formulated SQL statement.  We have already argued in favor of the beneficial outcomes that would be supported by such a tool.  Work still remains, however, to show that building such a tool is possible.

An essential part of such a tool would be a theorem-prover engine that can prove the validity of assertions.  The purpose of this chapter is to establish the feasibility of Prolog as an adequate prototyping prover environment for POQ.  The fundamental concepts that are understood, manipulated, and exercised in a Prolog system are axioms, inference rules, and proof derivation.  This certainly indicates that Prolog has theorem-proving capabilities built in.  Yet, for various reasons it is not possible to treat a standard Prolog environment as a full-fledged theorem prover in its own right.  This chapter provides details on the weaknesses of Prolog that prevent its acceptance as a (true, complete, indisputable, unassailable) automated theorem prover.  However, carefully restricted use of a subset of Prolog is indeed valid for determining the success of early prototypes of POQ.


1. SUB-SECTION:  preliminary definitions

Any discussion of Prolog is always firmly rooted in basic notions from first order logic.  This section establishes basic notation and definitions that will be useful throughout the remainder of the chapter.  We assume the reader is already familiar with the syntax of well-formed formulas of propositional logic and well-formed formulas of predicate logic.  This preliminary section is intended to clarify the particular set of symbols used.  It is not intended as any sort of tutorial or guide to FOL syntax. (rephrase).

Use FOL and predicate logic interchangeably.

relatively standard

/\  logical and
V logical or
-L  not
-> implication
_|_  absurdum / contradiction

symbols that are less standard, but common in discussions of prolog:

<-  implication, with the operands in reverse order
[]  (the square) absurdum

Also:  LOWER-CASE letters for atomic formula, so as not to end up with confusion later on.  upper case letters are always VARIABLES in Prolog ...

Two other ideas that will play a central role in this chapter: interpretations and refutation.

Both propositional and predicate logic are designed for determining the truth or falsity of formulas.  In order to make the determination, it is necessary to establish both the targeted formula, and also an interpretation for the formula.  An interpretation is simply a mapping of the formulaic symbols to the domain-specific concepts that the symbols are intended to represent.  Here are a few classic examples:

Formula: A  ^  B                         // fix the casing!
Interpretation:  A represents ""; B represents ""
Valuation: statement is true.

Formula: A  ^  B                          // fix the casing!
Interpretation:  A represents ""; B represents ""
Valuation: statement is true.

         [ ( 2 + 5 ) > 1 ] -> [ 5 > ( 1 - 2 ) ]
Formula: [ ( x + y ) > z ] -> [ y > ( z - x ) ]
Interpretation: x, y, and z represent the integers 2,5,1. '+', '-', and '>' represent the usual well-known operations of integer arithmetic.
Valuation: statement is true.


Refutation.

refutability is an antonym of satisfiability.

If the given interpretation allows us to conclude that a formula is false, then we have found a refutation for the formula.

Classical logic enables one to reason by contradiction.  A proof of X can be established by assuming -LX and establishing that this leads to a contradiction.

2. SUB-SECTION:  Basic usage and theory of Prolog

Modern prolog systems have a wide variety of uses.  In this section we will examine two uses in particular.  The use that is most import ....

A prolog system can be employed to directly exploit the proof system that drives the computation of all prolog output.  Alternatively, that same proof system can be used in its 'procedural interpretation', which is what enables the prolog user to employ prolog as a general purpose programming language.

There are several other interpretations and uses of prolog which we will not cover here. (footnote on database interpretation and concurrent interpretation). However, the diversity that is evident even in the two uses mentioned here is quite remarkable.

The following discussion will begin by using a snippet of Prolog source code as a centerpiece.  This immediately illustrates that reading a Prolog text as if it were a typical imperative-language software source code is very straightforward.  We then work backwards from this procedural reading in order to expose the underlying FOL principles.

To be clear: Prolog is definitely not an imperative language.  However, it has properties that can give it the 'look and feel' of an imperative language.  Those properties will be examined further as this section develops.

Here is the Prolog snippet to be discussed:

% Note: 'rect' is an abbreviation for rectangle,
% and 'usernm' is an abbreviation for username

% This procedure calculates the amount of "screen real estate" that
% will be needed to draw the current username onto the display

bounding_rect_for_drawing_usernm( ... ) :-
    get_font_setting( ... ),
    get_trimmed_usernm_string( ... ),
    calculate_bounding_rect_for_string_and_font( ... ).

We have used '...' to elide the input/output parameters that would normally appear enclosed between each pair of parentheses.  Other than that, the above snippet is valid and syntactically correct Prolog code.  Text appearing after a '%' character is simply commentary, and is not interpreted or executed in any way.

Even a relative beginner to computer programming can readily grasp the structure and intended purpose of the preceding code.  The code seems to indicate that there is a procedure named bounding_rect_for_drawing_usernm.  If we assume that this procedure resides in some available library of functionality (code library? how can i not simply say 'library', but instead say something specific but not overwrought?), then a sensible conclusion would be that we can call this procedure in our code once we indicate our reliance on the library.  When bounding_rect_for_drawing_usernm is called, we can see from its source code that it apparently calls three other procedures in order to accomplish its work.

This procedural reading of the code does provide a correct view of the intended meaning of the code, and also provides a correct view of the ultimate result of executing this code.  What makes Prolog quite drastically different from all the familiar imperative languages is the execution mechanism used to actually drive the specific path through the source code in order to arrive at a result.

In Prolog, the Prolog interpreter does not in fact "call the function bounding_rect_for_drawing_usernm."  Instead, Prolog must be given bounding_rect_for_drawing_usernm as a <i>goal</i>, and computation proceeds via a series of goal reduction operations.  The implementation details of Prolog's goal reduction computations differ markedly from the typical imperative-programming idea of making function calls and returning from function calls. (details of goal reduction will follow)

Despite the significant difference between function calls and goal reductions, it is sensible (permissible) to view bounding_rect_for_drawing_usernm <i>as if</i> it were a callable procedure.  The basis for the exchangeability of the procedural view and the goal-reduction view is due to the ground-breaking (hypen?) work by Kowalski showing that a particular fragment of FOL has a <i>procedural interpretation</i>.  In other words, the earlier snippet of code is simply one possible interpretation of the following FOL formula:

    A <- ( B ^ C ^ D ).    // fix the casing!

(next paragraph needs heavy revision. goal is to say: "wow this is so revolutionary!" -- hopefully without sounding silly)
Recall the earlier examples of semantic interpretations given in section XYZ.  For hundreds of years, logicians produced (worked with) interpretations of logic formulas that were all very similar to those interpretations shown in section XYZ.  Typical interpretations involved domains such as integers and real numbers on the one hand, and the domains of arguments and assertions about the natural world on the other.  Furthermore, the old 'typical' interpretations produced interpreted formulas that were seen as static assertions of facts and properties of the domain objects.  Interpretations of formulas had not been used to define an executable algorithmic process.  Kowalski's insight about how to interpret FOL itself as a programming language was revolutionary, and has given us a new and separate programming paradigm to study alongside the functional and imperative paradigms.

The 'procedural interpretation' of FOL has historically been defined on a fragment of FOL that is restricted to formulas in Horn clause form.  In keeping with standard definitions throughout all fields (subfields, etc) of propositional and predicate logic, a <i>clause</i> is a disjunction of literals.  A Horn clause, then, is a clause having no more than one positive literal (and any number -- zero or more -- negative literals).

The following is a typical Horn clause:

    A v -B v -C    // fix the casing!

Because of several well-known logical equivalences including X <- Y === X v -Y (and the distribuitivity? of v and negation), the same Horn clause can also be expressed as:

    A <- (B /\ C)        // fix the casing!

This is why the Horn clause A v -B v -C is expressed in Prolog as:

    a :- b, c.

Note that in Prolog ':-' is the notation used for <-, and the comma represents conjunction.

According to the procedural interpretation, a set of Horn clauses such as:

    A v -B v -C
    M V -N
    Z v -X v -Y v -Z

represents a program.  Each Horn clause with a single positive literal is a procedure declaration.

To initiate computation using a given program, we must provide the system with a goal clause.  The goal clause represents what we want to compute, such as the goal of bounding_rect_for_drawing_usernm.

Stating a goal is analogous to proposing a new theorem which we would like to prove.  The computation proceeds by using the program clauses as axioms and deriving a proof to show -- in a successful case -- that the proposed theorem is indeed a logical consequence of the axioms.

If the proposed theorem (the goal clause) is a logical consequence of the program clauses, then every model (ok... now we have to go back an introduce model somewhere...) that validates the program clauses will necessarily validate the goal clause. (this is by definition of entailment, logical consequence).

The proof procedure (described later) is a refutation procedure, so we therefore proceed using proof by contradiction.  We initiate a proof procedure to show:

    program clauses UNION (negation of goal)

is satisfiable.  If the above set of clauses is satisfiable, then this contradicts the original idea that (goal) was necessarily entailed by program, so we cannot prove the proposed theorem.

Assuming that we seek a successful computation, then once the procedure begins operating on

    program clauses UNION (negation of goal)

we would actually like to derive a contradiction, which would indicate a successful proof of the original proposed theorem.

As we said earlier, the role of program interpreter is played by the proof procedure.  In Prolog, the proof procedure is a refinement of Robinson's resolution procedure (rule? inference? check precise terminology).

Here is a simplified demonstration of how resolution works:

Let the program clauses be:

c1: r v -p v -b
c2: b v -p
c3: p

The new theorem (the goal) is: r, so we negate that in preparation for the proof-by-contradiction.  The negated proposed theorem is added to set of the program clauses, yielding:

c1: r v -p v -b
c2: b v -p
c3: p
g:  -r

If the resolution procedure derives a contradiction, then we have proved the theorem ''.

Resolution procedes by repeatedly finding a pair of clauses in the set that ..., and adding the <i>resolvent</i> of the pair to the total set of clauses.  (define resolvent).  In a successful computation, eventually the resolvent of some pair will be [] (box), which indicates the desired contradiction.

Continuing the example:

From c1 and c2, use the resolution rule to infer:

c4: r v -p

From c4 and c3, infer:

c5: r

We can see that g and c5 yield a contradiction.  From g and c5 we derive [], which was the desired result.  The proof of the theoremhood of r is complete.

All that has been shown in this simplified demonstration is the resolution rule as applied to propositional formulas.  However, when Robinson discovered resolution there were already highly effective procedures for deciding the satisfiability and unsatisfiability of sets of propositional clauses.  The real power of resolution lies in the fact that Robinson was able to define an extended form that works for any set of first-order clauses.  This means that the clauses can contain predicates and functions of arbitrary arities instead of simply propositions.

Prolog permits functional notation and predicates of arbitrary arities.  Therefore, Prolog relies on the extended FOL version of resolution in its full generality. (... add a few more explanatory notes about general resolution here...)

Despite the simplifications use to show the brief demonstration of resolution given above, the demonstration is sufficient to clarify the few remaining points about the computation steps involved in executing Prolog source code.

Returning to our original source code snippet, we can now provide specifics about how the execution path through a 'procedure call' to bounding_rect_for_drawing_usernm is fundamentally different from an execution path through a similarly coded procedure in a typical imperative programming language.

Recall that we assumed that the code snippet for bounding_rect_for_drawing_usernm would be present as a library routine in our program.

This means that our program consists of a set of predicate logic Horn clauses like so:

    ....
    b v -g1 v -g2 v -c
    ...

where b stands for bounding_rect_for_drawing_usernm, g1 stands for get_font_setting, g2 stands for get_trimmed_usernm_string, and c stands for calculate_bounding_rect_for_string_and_font.

To make a 'procedure call' to bounding_rect_for_drawing_usernm, what actually happens in a Prolog system is that bounding_rect_for_drawing_usernm is posed as a prospective theorem to be proved, also known as a goal statement.  The proof attempt proceeds by contradiction, so we negate bounding_rect_for_drawing_usernm, yielding a set of clauses:

    ....
    b v -g1 v -g2 v -c
    ...
    -b

This set is input to the resolution procedure, which continuously derives resolvents until we (hopefully) derive the contradiction [].

Clearly, the given set of clauses immediately allows for the derivation of:

    -g1 v -g2 v -c

To complete the 'procedure call' to bounding_rect_for_drawing_usernm, we must continue making logical inferences in this way until we derive [].  To complete the call in this example, we require that somewhere in the set of program clauses there is a clause containing the positive literal g1.  Likewise, there must be a program clause containing the positive literal g2, and another clause containing c.

Still to cover: non-determinism. backtracking.  then that should be it for this section.



my own review/revision notes.  make sure these points are covered adequately:

set of 'procedure declarations' is a program.

'procedure declaration' is a horn clause with one positive literal. (may have 0 negative literals).

a horn clause with zero positive (all negative) is a goal statement.

the empty clause is a halt statement.

we wish to derive contradiction [] (box), which means the program halted successfully.

the proof procedure is the interpreter.


my own review/revision notes.  this might go in this chapter, or perhaps in the next chapter:

another key strength of prolog: that when a proof is found (the refutation of the -Lgoal which proves goal), we also get a satisfying assignment.


3. SUB-SECTION:  Weaknesses and limitations of Prolog.

We have seen that a standard Prolog system is __________(proof-related...).  Prolog's ability to serve as a programming language has also been established.  For the purposes of protyping POQ we require Prolog to serve as a rudimentary theorem prover.  In other words, while building POQ we will not use Prolog to define <i>procedures<i> such as bounding_rect_for_drawing_usernm.  Instead, we need to use Prolog in order to codify axioms about SQL statements, such as ...

[some SQL here] ===>> [ some axioms here ]

However, Prolog systems include trade-offs that favor the use of Prolog as a general purpose programming language and deemphasize its theorem-proving capabilities.  Only by enumerating and cataloguing these weaknesses can we be certain that POQ will only use Prolog's theorem-proving assets in an effective way.

For a prototype system, we accept weaknesses that may lead to a loss of completeness.  However, we categorically exclude the use of any Prolog features that would yield a loss of soundness.  Once the fundamental aspects of soundness and completeness have been considered, we must also note where certain implementation details of Prolog systems can hurt the efficiency of finding proofs.  Here, too, we may accept a known loss of efficiency (compared to "full-service" provers) in order to benefit from the ease-of-use (simplicity, ample documentation) of Prolog.




Because ...
The use of prolog for general purpose programming has always been a principal motivator...

trade-offs were made ... for efficiency and (determinism), and they sometimes run counter to the 'pure logic' view of the language. here we mention occur check and ordering (logically equivalent statements where one formulation causes an infinite search).

there is one 'weak point' of the language that comes from the logic itself and not from any mundane performance trade-off.  that is the problem of negation.


lack of occurs check is a threat to soundness.  the depth-first search opening the door to infinite paths is a threat to completeness.


weaknesses:

unsound unification
depth-first search (infinite paths)
arithmetic and "equals"
negation, non-horn clauses

meta-logical stuff: var, name, functor
retract, assert
cut



---------================-------------------









we can address unsound unification by using a flag to reenable the occurs check.
we can address the infinite search tree paths by: (list my strategies and explain them)

as for 'non-horn clauses' â€“ we do not need any. (could this be due to closed-world assumption in database? not 100% sure if that is precisely why or just a coincidence)

